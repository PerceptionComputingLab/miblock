from matplotlib import pyplot as plt
import numpy as np
import os
import nibabel as nib
import cv2 as cv
from imageio import volread, mvolread
import glob
import re


# 该函数将一个字符序列中的数字取出来，放入字典中，字典中还包括整个序列
def str2dic(pathstr, re_str):
    # 此处用到了正则表达式的切分功能
    b = re.split(re_str, os.path.basename(pathstr))
    temparr = []
    for i in range(0, len(b)):
        if b[i].isdigit() == True:
            tempp = int(b[i])
            temparr.append(tempp)
        else:
            continue
    if len(temparr) > 1:
        split_dict = {'count': temparr[0], 'slice': temparr[1], 'fullname': pathstr}
    elif len(temparr) == 1:
        split_dict = {'count': b[0], 'slice': temparr[0], 'fullname': pathstr}
    else:
        raise Exception('False Input Data!')

    return split_dict


def sort_path(dir_path, file_type):
    imgpathlist = glob.glob(os.path.join(dir_path, file_type))
    list_dict = []
    pattern = r'[\_\-\(\)\.\\]+'
    for imgpath in imgpathlist:
        str_dict = str2dic(imgpath, pattern)
        list_dict.append(str_dict)
    list_dict.sort(key=lambda x: x["slice"])
    a = 1
    return list_dict


def apply_mask(image, mask, color_list, alpha=0.5):
    """Apply the given mask to the image.
    """
    for c in range(image.shape[-1]):
        image[:, :, c] = np.where(mask == 1,
                                  image[:, :, c] *
                                  (1 - alpha) + alpha * color_list[c],
                                  image[:, :, c])
    return image


def get_rect(img_path):
    # 该函数输入lable图像的地址，读取图像，并从中得到区域中所有非零连通区域最小外接矩形的坐标
    # 最终返回box的list,其中box=[x_min,y_min,x_max,y_max],以及带框的图像
    image = cv.imread(img_path)
    image = image * 255
    gray_img = cv.cvtColor(image, cv.COLOR_BGR2GRAY)
    ret, binary = cv.threshold(gray_img, 127, 255, cv.THRESH_BINARY)
    # 注意 不同版本opencv 该函数有变化！！
    # hierachy, contours, offset = cv.findContours(binary, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_NONE)
    contours, hierachy = cv.findContours(binary, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_NONE)
    boxs = []
    for contour in contours:
        # 求每条轮廓行列的最大，最小值
        Point_contour = contour.shape[0]
        x_min = 5000
        x_max = -200
        y_min = 5000
        y_max = -200
        for i in range(0, Point_contour):
            temp1 = contour[i][0][0]
            temp2 = contour[i][0][1]
            if x_min > temp1:
                x_min = temp1
            if x_max < temp1:
                x_max = temp1
            if y_min > temp2:
                y_min = temp2
            if y_max < temp2:
                y_max = temp2
        alpha = 10
        box = [int(x_min), int(y_min), int(x_max), int(y_max)]
        shape = image.shape
        box_large = [max(0, int(x_min - alpha)), max(0, int(y_min - alpha)), min(shape[0] - 1, int(x_max + alpha)),
                     min(shape[1] - 1, int(y_max + alpha))]

        p1 = (max(0, int(x_min - alpha)), max(0, int(y_min - alpha)))
        p2 = (min(shape[0] - 1, int(x_max + alpha)), min(shape[1] - 1, int(y_max + alpha)))
        cv.rectangle(image, p1, p2, (0, 0, 255), 1)
        boxs.append(box_large)
    return boxs, image


def save_slice_img(self, volume_path, output_path):
    file_name = os.path.basename(volume_path)
    output_dir = os.path.join(output_path, file_name)
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    else:
        pass
    input_volume = nib.load(volume_path).get_data()
    # mapping to 0-1
    vol_max = np.max(input_volume)
    vol_min = np.min(input_volume)
    input_unit = (input_volume - vol_min) / (vol_max - vol_min)
    width, height, depth = input_unit.shape
    for i in range(0, depth):
        slice_path = os.path.join(output_dir, str(i) + '.png')
        img_i = input_unit[:, :, i]
        # normalize to 0-255
        img_i = (img_i * 255).astype('uint8')
        cv.imwrite(slice_path, img_i)
    return input_unit


def save_contour_label(img, pre, classes=None, save_path='', colors=None, file_name=None, show_mask=True,
                       alpha=1.0):
    # single channel to multi-channel
    img = np.expand_dims(img, axis=-1)
    img = np.tile(img, (1, 1, 3))
    height, width = img.shape[:2]
    _, ax = plt.subplots(1, figsize=(height, width))

    # ax.set_ylim(height + 10, -10)
    # ax.set_xlim(-10, width + 10)
    ax.set_ylim(height + 0, 0)
    ax.set_xlim(0, width + 0)
    ax.axis('off')
    # ax.set_title("volume mask")
    masked_image = img.astype(np.uint32).copy()

    if show_mask:
        masked_image = apply_mask(masked_image, pre, colors, classes, alpha)

    # reduce the blank part generated by plt and keep the original resolution
    fig = plt.gcf()
    fig.set_size_inches(height / 300, width / 300)
    plt.gca().xaxis.set_major_locator(plt.NullLocator())
    plt.gca().yaxis.set_major_locator(plt.NullLocator())
    plt.subplots_adjust(top=1, bottom=0, right=1, left=0, hspace=0, wspace=0)
    plt.margins(0, 0)

    ax.imshow(masked_image.astype(np.uint8))
    # plt.show()
    fig.savefig('{}/{}.png'.format(save_path, file_name), dpi=300)
    # clear the image after saving
    plt.cla()
    plt.close(fig)


def mat2gray(I, limits):
    '''
    Apply intensity transformation + window operation for CT value
    :param I: input data
    :param limits:  Interested Value Range
    :return: transformed data
    '''
    i = I.astype(np.float32)
    graymax = float(limits[1])
    graymin = float(limits[0])
    delta = 1 / (graymax - graymin)
    gray = delta * i - graymin * delta
    graycut = np.maximum(0, np.minimum(gray, 1))
    return graycut * 255.0

    # 将一个体数据以及预测结果和GT保存为逐个切片叠加的形式进行可视化


def save_slice_img_label(volume_path, pre_path, output_path,
                         window=None, show_mask=False, color=None, classes=None, alpha=0.5):
    img_volume = nib.load(volume_path).get_data()
    pre_volume = nib.load(pre_path).get_data()

    img_volume = img_volume.transpose(1, 0, 2)
    pre_volume = pre_volume.transpose(1, 0, 2)
    assert img_volume.shape == pre_volume.shape
    _, _, depth = img_volume.shape

    img_volume = img_volume.astype("float32")
    if window != None:
        img_volume = mat2gray(img_volume, window)

    # gray value mapping   from MRI value to pixel value(0-255)
    volume_max = np.max(img_volume)
    volume_min = np.min(img_volume)
    volum_mapped = (img_volume - volume_min) / (volume_max - volume_min)
    volum_mapped = (255 * volum_mapped).astype('uint8')
    # construct a directory for each volume to save slices
    # dir_volume = os.path.join(output_path, file_name)
    if not os.path.exists(output_path):
        os.makedirs(output_path)
    else:
        pass
    for i in range(depth):
        img_slice = volum_mapped[:, :, i]
        pre_slice = pre_volume[:, :, i]
        save_contour_label(img=img_slice, pre=pre_slice, classes=classes,
                           save_path=output_path, colors=color, file_name=i,
                           show_mask=show_mask, alpha=alpha)


def ct_read(save_path):
    ct_general_width = 100
    ct_general_center = 40
    root_path = r"E:\E\MRI-CT\label\doctor\CT\original"
    dcm_path = os.path.join(root_path, "DICOM")
    png_path = os.path.join(root_path, "PNG")
    subjects = os.listdir(dcm_path)
    if not os.path.exists(save_path): os.mkdir(save_path)
    save_img_path = os.path.join(save_path, "image")
    save_label_path = os.path.join(save_path, "label")
    if not os.path.exists(save_img_path): os.mkdir(save_img_path)
    if not os.path.exists(save_label_path): os.mkdir(save_label_path)

    # 实例化保存图像并画GT的类

    subjects1 = ['045', '065', '104', '186', '071']
    subjects = ['158']
    # subjects = ['071']
    for subject in subjects:
        path = os.path.join(dcm_path, subject)
        path2 = path.replace("\\", "/")

        # PNG label read
        path_png = os.path.join(png_path, subject)

        file_type_label = '*.png'
        sorted_dict_L = sort_path(path_png, file_type_label)

        slice_list = []

        for i in range(len(sorted_dict_L)):
            label = cv.imread(sorted_dict_L[i]["fullname"], cv.IMREAD_GRAYSCALE)
            slice_list.append(label)
        volume_label = np.array(slice_list, dtype="int16")

        label_shape = volume_label.shape
        vol = mvolread(path2, format='DICOM')
        # vol = volread(path2, format='DICOM')

        # 查看各个文件夹的维度数量,用来确定对应的DICOM文件
        if isinstance(vol, list):
            num = len(vol)
            for i in range(num):
                shape = vol[i].shape
                if shape == label_shape:
                    data_volume = vol[i]
                    break
                else:
                    pass
        else:
            data_volume = vol

        data_window = mat2gray(data_volume,
                               [ct_general_center - ct_general_width / 2, ct_general_center + ct_general_width / 2])
        data_show = (data_window * 255).astype("uint8")

        save_img_path_subject = os.path.join(save_img_path, subject)
        save_label_path_subject = os.path.join(save_label_path, subject)
        if not os.path.exists(save_img_path_subject): os.mkdir(save_img_path_subject)
        if not os.path.exists(save_label_path_subject): os.makedirs(save_label_path_subject)

        for i in range(data_show.shape[0]):
            if data_show[i, ...].shape != (512, 512):
                print(save_img_path_subject + "{}".format(i))
            # cv.imshow("image", data_show[i, ...])
            # cv.imshow("label", volume_label[i,...].astype("uint8")*255)
            # cv.waitKey(500)
            # 保存图像和label
            cv.imwrite('{}/{}.png'.format(save_img_path_subject, str(i)), data_show[i, ...])
            cv.imwrite('{}/{}.png'.format(save_label_path_subject, str(i)),
                       (volume_label[i, ...] * 255).astype("uint8"))
            # eval.save_contour_label(data_show[i, ...],volume_label[i,...].astype("uint8"),gt=None,save_path= save_img_path_subject,file_name=str(i))
        a = 1
